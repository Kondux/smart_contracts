{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity >=0.8.9;\r\n\r\ninterface IAuthority {\r\n    /* ========== EVENTS ========== */\r\n\r\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\r\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\r\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\r\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\r\n    event RolePushed(address indexed account, bytes32 _role);\r\n\r\n    event GovernorPulled(address indexed from, address indexed to);\r\n    event GuardianPulled(address indexed from, address indexed to);\r\n    event PolicyPulled(address indexed from, address indexed to);\r\n    event VaultPulled(address indexed from, address indexed to);\r\n\r\n    /* ========== VIEW ========== */\r\n\r\n    function governor() external view returns (address);\r\n\r\n    function guardian() external view returns (address);\r\n\r\n    function policy() external view returns (address);\r\n\r\n    function vault() external view returns (address);\r\n\r\n    function roles(address _addr) external view returns (bytes32);\r\n\r\n}\r\n"
    },
    "contracts/interfaces/IKonduxERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n\r\ninterface IKonduxERC20 is IERC20 {\r\n    function excludedFromFees(address) external view returns (bool);\r\n    function tradingOpen() external view returns (bool);\r\n    function taxSwapMin() external view returns (uint256);\r\n    function taxSwapMax() external view returns (uint256);\r\n    function _isLiqPool(address) external view returns (bool);\r\n    function taxRateBuy() external view returns (uint8);\r\n    function taxRateSell() external view returns (uint8);\r\n    function antiBotEnabled() external view returns (bool);\r\n    function excludedFromAntiBot(address) external view returns (bool);\r\n    function _lastSwapBlock(address) external view returns (uint256);\r\n    function taxWallet() external view returns (address);\r\n\r\n    event TokensAirdropped(uint256 totalWallets, uint256 totalTokens);\r\n    event TokensBurned(address indexed burnedByWallet, uint256 tokenAmount);\r\n    event TaxWalletChanged(address newTaxWallet);\r\n    event TaxRateChanged(uint8 newBuyTax, uint8 newSellTax);\r\n\r\n    function initLP() external;\r\n    function enableTrading() external;\r\n    function burnTokens(uint256 amount) external;\r\n    function enableAntiBot(bool isEnabled) external;\r\n    function excludeFromAntiBot(address wallet, bool isExcluded) external;\r\n    function excludeFromFees(address wallet, bool isExcluded) external;\r\n    function adjustTaxRate(uint8 newBuyTax, uint8 newSellTax) external;\r\n    function setTaxWallet(address newTaxWallet) external;\r\n    function taxSwapSettings(uint32 minValue, uint32 minDivider, uint32 maxValue, uint32 maxDivider) external;\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\tfunction decimals() external view returns (uint8);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction name() external view returns (string memory);\r\n\tfunction getOwner() external view returns (address);\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\tfunction allowance(address _owner, address spender) external view returns (uint256);\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"./interfaces/IKonduxERC20.sol\";\r\nimport \"./types/AccessControlled.sol\";\r\n\r\n/**\r\n * @title Treasury\r\n * @dev This contract handles deposits and withdrawals of tokens and Ether.\r\n */\r\ncontract Treasury is AccessControlled {\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event Deposit(address indexed token, uint256 amount);\r\n    event DepositEther(uint256 amount);\r\n    event EtherDeposit(uint256 amount);\r\n    event Withdrawal(address indexed token, uint256 amount);\r\n    event EtherWithdrawal(address to, uint256 amount);\r\n\r\n    /* ========== DATA STRUCTURES ========== */\r\n\r\n    enum STATUS {\r\n        RESERVEDEPOSITOR,\r\n        RESERVESPENDER,\r\n        RESERVETOKEN\r\n    }\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    string internal notAccepted = \"Treasury: not accepted\";\r\n    string internal notApproved = \"Treasury: not approved\";\r\n    string internal invalidToken = \"Treasury: invalid token\";\r\n\r\n    mapping(STATUS => mapping(address => bool)) public permissions;\r\n    mapping(address => bool) public isTokenApproved;\r\n    \r\n    address[] public approvedTokensList;\r\n    uint256 public approvedTokensCount;\r\n\r\n    address public stakingContract;\r\n\r\n    /**\r\n     * @dev Initializes the Treasury contract.\r\n     * @param _authority The address of the authority contract.\r\n     */\r\n    constructor(address _authority) AccessControlled(IAuthority(_authority)) {\r\n        approvedTokensCount = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Allow approved address to deposit an asset for Kondux.\r\n     * @dev Deposits a specified amount of the specified token.\r\n     * @param _amount The amount of tokens to deposit.\r\n     * @param _token The address of the token contract.\r\n     */\r\n    function deposit(\r\n        uint256 _amount,\r\n        address _token\r\n    ) external {\r\n        if (permissions[STATUS.RESERVETOKEN][_token]) {\r\n            require(permissions[STATUS.RESERVEDEPOSITOR][msg.sender], notApproved);\r\n        } else {\r\n            revert(invalidToken);\r\n        }\r\n\r\n        IKonduxERC20(_token).transferFrom(tx.origin, address(this), _amount);\r\n        // get allowance and increase it\r\n        uint256 allowance = IKonduxERC20(_token).allowance(stakingContract, _token);\r\n        IKonduxERC20(_token).approve(stakingContract, allowance + _amount);\r\n\r\n        emit Deposit(_token, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Allow approved address to deposit Ether.\r\n     * @dev Deposits Ether to the contract.\r\n     */\r\n    function depositEther () external payable {\r\n        require(permissions[STATUS.RESERVEDEPOSITOR][msg.sender], notApproved);  \r\n                \r\n        emit DepositEther(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @notice Allow approved address to withdraw Kondux from reserves.\r\n     * @dev Withdraws a specified amount of the specified token.\r\n     * @param _amount The amount of tokens to withdraw.\r\n     * @param _token The address of the token contract.\r\n     */\r\n    function withdraw(uint256 _amount, address _token) external {\r\n        require(permissions[STATUS.RESERVETOKEN][_token], notAccepted); // Only reserves can be used for redemptions\r\n        require(permissions[STATUS.RESERVESPENDER][msg.sender], notApproved);\r\n\r\n        IKonduxERC20(_token).transfer(msg.sender,         _amount);\r\n\r\n        emit Withdrawal(_token, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Receives Ether.\r\n     */\r\n    receive() external payable {\r\n        emit EtherDeposit(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function for receiving Ether.\r\n     */\r\n    fallback() external payable { \r\n        emit EtherDeposit(msg.value); \r\n    }\r\n    \r\n    /**\r\n     * @notice Allow approved address to withdraw Ether.\r\n     * @dev Withdraws a specified amount of Ether.\r\n     * @param _amount The amount of Ether to withdraw.\r\n     */\r\n    function withdrawEther(uint _amount) external {\r\n        require(permissions[STATUS.RESERVESPENDER][msg.sender], notApproved);\r\n        require(payable(msg.sender).send(_amount));\r\n\r\n        emit EtherWithdrawal(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets permissions for the specified address.\r\n     * @param _status The status to set the permission for.\r\n     * @param _address The address to set the permission for.\r\n     * @param _permission The permission value to set.\r\n     */\r\n    function setPermission(\r\n        STATUS _status,\r\n        address _address,\r\n        bool _permission\r\n    ) public onlyGovernor {\r\n        // Check if the address is non-zero\r\n        require(_address != address(0), \"Treasury Permission: zero address\");\r\n        permissions[_status][_address] = _permission;\r\n        if (_status == STATUS.RESERVETOKEN) {\r\n            isTokenApproved[_address] = _permission;\r\n            if (_permission) {\r\n                approvedTokensList.push(_address);\r\n                approvedTokensCount++;                \r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the staking contract address.\r\n     * @param _stakingContract The address of the staking contract.\r\n     */\r\n    function setStakingContract(address _stakingContract) public onlyGovernor {\r\n        // Check if the address is non-zero\r\n        require(_stakingContract != address(0), \"Treasury SetStakingContract: zero address\");\r\n        require(_stakingContract != stakingContract, \"Treasury SetStakingContract: same address\");\r\n        \r\n        stakingContract = _stakingContract;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets up the ERC20 token approval.\r\n     * @param _token The address of the token contract.\r\n     * @param _amount The amount to approve.\r\n     */\r\n    function erc20ApprovalSetup(address _token, uint256 _amount) public onlyGovernor {\r\n        IKonduxERC20(_token).approve(stakingContract, _amount);\r\n    }\r\n\r\n    // Getters\r\n\r\n    /**\r\n     * @dev Returns the list of approved tokens.\r\n     * @return An array of approved token addresses.\r\n     */\r\n    function getApprovedTokensList() public view returns (address[] memory) {\r\n        return approvedTokensList;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the count of approved tokens.\r\n     * @return The number of approved tokens.\r\n     */\r\n    function getApprovedTokensCount() public view returns (uint256) {\r\n        return approvedTokensCount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the approved token at the specified index.\r\n     * @param _index The index of the approved token.\r\n     * @return The address of the approved token at the given index.\r\n     */\r\n    function getApprovedToken(uint256 _index) public view returns (address) {\r\n        return approvedTokensList[_index];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the allowance of the approved token for the staking contract.\r\n     * @param _token The address of the approved token.\r\n     * @return The allowance of the approved token for the staking contract.\r\n     */\r\n    function getApprovedTokenAllowance(address _token) public view returns (uint256) {\r\n        return IKonduxERC20(_token).allowance(stakingContract, _token);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the balance of the approved token in the treasury.\r\n     * @param _token The address of the approved token.\r\n     * @return The balance of the approved token in the treasury.\r\n     */\r\n    function getApprovedTokenBalance(address _token) public view returns (uint256) {\r\n        return IKonduxERC20(_token).balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the Ether balance of the treasury.\r\n     * @return The Ether balance of the treasury.\r\n     */\r\n    function getEtherBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the staking contract.\r\n     * @return The address of the staking contract.\r\n     */\r\n    function getStakingContract() public view returns (address) {\r\n        return stakingContract;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the allowance of the token for the staking contract.\r\n     * @param _token The address of the token.\r\n     * @return The allowance of the token for the staking contract.\r\n     */\r\n    function getStakingContractAllowance(address _token) public view returns (uint256) {\r\n        return IKonduxERC20(_token).allowance(address(this), stakingContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the balance of the token in the staking contract.\r\n     * @param _token The address of the token.\r\n     * @return The balance of the token in the staking contract.\r\n     */\r\n    function getStakingContractBalance(address _token) public view returns (uint256) {\r\n        return IKonduxERC20(_token).balanceOf(stakingContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the Ether balance of the staking contract.\r\n     * @return The Ether balance of the staking contract.\r\n     */\r\n    function getStakingContractEtherBalance() public view returns (uint256) {\r\n        return stakingContract.balance;\r\n    }\r\n\r\n}\r\n\r\n\r\n"
    },
    "contracts/types/AccessControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"../interfaces/IAuthority.sol\";\r\n\r\n/// @dev Reasoning for this contract = modifiers literaly copy code\r\n/// instead of pointing towards the logic to execute. Over many\r\n/// functions this bloats contract size unnecessarily.\r\n/// imho modifiers are a meme.\r\nabstract contract AccessControlled {\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AuthorityUpdated(IAuthority authority);\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    IAuthority public authority;\r\n\r\n    /* ========== Constructor ========== */\r\n\r\n    constructor(IAuthority _authority) {\r\n        require(address(_authority) != address(0), \"Authority cannot be zero address\");\r\n        authority = _authority;\r\n        emit AuthorityUpdated(_authority);\r\n    }\r\n\r\n    /* ========== \"MODIFIERS\" ========== */\r\n\r\n    modifier onlyGovernor {\r\n        _onlyGovernor();\r\n        _;\r\n    }\r\n\r\n    modifier onlyGuardian {\r\n        _onlyGuardian();\r\n        _;\r\n    }\r\n\r\n    modifier onlyPolicy {\r\n        _onlyPolicy();\r\n        _;\r\n    }\r\n\r\n    modifier onlyVault {\r\n        _onlyVault();\r\n        _;\r\n    }\r\n\r\n    modifier onlyGlobalRole(bytes32 _role){\r\n        _onlyRole(_role);\r\n        _;\r\n    }\r\n\r\n    /* ========== GOV ONLY ========== */\r\n\r\n    function initializeAuthority(IAuthority _newAuthority) internal {\r\n        require(authority == IAuthority(address(0)), \"AUTHORITY_INITIALIZED\");\r\n        authority = _newAuthority;\r\n        emit AuthorityUpdated(_newAuthority);\r\n    }\r\n\r\n    function setAuthority(IAuthority _newAuthority) external {\r\n        _onlyGovernor();\r\n        authority = _newAuthority;\r\n        emit AuthorityUpdated(_newAuthority);\r\n    }\r\n\r\n    /* ========== INTERNAL CHECKS ========== */\r\n\r\n    function _onlyGovernor() internal view {\r\n        require(msg.sender == authority.governor(), \"UNAUTHORIZED\");\r\n    }\r\n\r\n    function _onlyGuardian() internal view {\r\n        require(msg.sender == authority.guardian(), \"UNAUTHORIZED\");\r\n    }\r\n\r\n    function _onlyPolicy() internal view {\r\n        require(msg.sender == authority.policy(), \"UNAUTHORIZED\");        \r\n    }\r\n\r\n    function _onlyVault() internal view {\r\n        require(msg.sender == authority.vault(), \"UNAUTHORIZED\");                \r\n    }\r\n\r\n    function _onlyRole(bytes32 _role) internal view {\r\n        require(authority.roles(msg.sender) == _role, \"UNAUTHORIZED\");\r\n    }\r\n  \r\n}\r\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}